<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>200x25 Dot Matrix Display</title>
    <!-- jQuery and Select2 CDN -->
    <script src="/static/js/jquery-3.6.0.min.js"></script>
    <link href="/static/css/select2.min.css" rel="stylesheet" />
    <script src="/static/js/select2.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background-color: #000;
            font-family: monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .matrix-container {
            background-color: #111;
            padding: 10px;
            border-radius: 5px;
            border: 2px solid #333;
        }

        .matrix-display {
            display: grid;
            grid-template-columns: repeat(200, 4px);
            grid-template-rows: repeat(25, 4px);
            gap: 1px;
            background-color: #000;
            padding: 5px;
        }

        .dot {
            width: 4px;
            height: 4px;
            background-color: #0a0a0a;
            border-radius: 50%;
            transition: background-color 0.1s ease;
        }

        .dot.on {
            background-color: #ffaa00;
            box-shadow: 0 0 3px #ffaa00;
        }

        .dot.amber {
            background-color: #ffaa00;
            box-shadow: 0 0 3px #ffaa00;
        }

        .dot.red {
            background-color: #ffaa00;
            box-shadow: 0 0 3px #ffaa00;
        }

        .controls {
            margin-top: 20px;
            color: #fff;
        }

        button {
            background-color: #333;
            color: #fff;
            border: 1px solid #555;
            padding: 8px 16px;
            margin: 5px;
            border-radius: 3px;
            cursor: pointer;
            font-family: monospace;
        }

        button:hover {
            background-color: #555;
        }

        .info {
            color: #888;
            margin-top: 10px;
            text-align: center;
        }

        /* Select2 custom styling */
        .select2-container--default .select2-selection--single {
            background-color: #333;
            border: 1px solid #555;
            color: #fff;
            height: 34px;
            line-height: 32px;
        }

        .select2-container--default .select2-selection--single .select2-selection__rendered {
            color: #fff;
            padding-left: 8px;
        }

        .select2-container--default .select2-selection--single .select2-selection__arrow {
            height: 32px;
        }

        .select2-dropdown {
            background-color: #333;
            border: 1px solid #555;
        }

        .select2-container--default .select2-results__option {
            background-color: #333;
            color: #fff;
        }

        .select2-container--default .select2-results__option--highlighted[aria-selected] {
            background-color: #555;
        }

        .select2-container--default .select2-search--dropdown .select2-search__field {
            background-color: #333;
            border: 1px solid #555;
            color: #fff;
        }

        .route-selector {
            margin-top: 15px;
            color: #fff;
        }

        .direction-toggle {
            margin-left: 10px;
        }
    </style>
</head>
<body>
    <div class="matrix-container">
        <div class="matrix-display" id="matrixDisplay">
            <!-- Dots will be generated by JavaScript -->
        </div>
    </div>

    <div class="controls">
        <button onclick="clearDisplay()">Clear</button>
        <button onclick="displayBusInfo()">Display</button>
    </div>

    <div class="pattern-controls" style="margin-top: 15px; color: #fff;">
        <h3 style="margin-bottom: 10px;">Display Patterns:</h3>
        <button onclick="displayPattern1()" style="background-color: #444;">Route + Dest Only</button>
        <button onclick="displayPattern2()" style="background-color: #666;">Normal</button>
        <button onclick="displayPattern3()" style="background-color: #444;">Dest Only (Full)</button>
    </div>
    
    <div class="route-selector" style="margin-top: 15px; color: #fff;">
        <h3 style="margin-bottom: 10px;">API Route Selection:</h3>
        <label for="routeSelect">Select Route:</label>
        <select id="routeSelect" style="width: 300px;">
            <option value="">Choose a route...</option>
        </select>
        <label class="direction-toggle">
            <input type="checkbox" id="directionToggle" checked> Inbound
        </label>
    </div>

    <div class="bus-controls" style="margin-top: 15px; color: #fff;">
        <div style="display: flex; gap: 20px; align-items: center; flex-wrap: wrap;">
            <div>
                <label for="routeInput">Route:</label>
                <input type="text" id="routeInput" value="" maxlength="3" style="width: 50px; margin-left: 5px; background: #333; color: #fff; border: 1px solid #555; padding: 3px;">
            </div>
            <div>
                <label for="destinationInput">Destination:</label>
                <input type="text" id="destinationInput" value="" maxlength="20" style="width: 200px; margin-left: 5px; background: #333; color: #fff; border: 1px solid #555; padding: 3px;">
            </div>
            <div>
                <label for="viaInput">Via:</label>
                <input type="text" id="viaInput" value="" maxlength="100" style="width: 200px; margin-left: 5px; background: #333; color: #fff; border: 1px solid #555; padding: 3px;">
            </div>
        </div>
    </div>

    <script>
        const COLS = 200;
        const ROWS = 25;
        let dots = [];
        let scrollInterval;
        let viaScrollInterval;

        // Initialize the matrix
        function initMatrix() {
            const container = document.getElementById('matrixDisplay');
            container.innerHTML = '';
            dots = [];

            for (let row = 0; row < ROWS; row++) {
                dots[row] = [];
                for (let col = 0; col < COLS; col++) {
                    const dot = document.createElement('div');
                    dot.className = 'dot';
                    dot.dataset.row = row;
                    dot.dataset.col = col;
                    
                    // Add click handler to toggle dots
                    dot.addEventListener('click', function() {
                        toggleDot(row, col);
                    });
                    
                    container.appendChild(dot);
                    dots[row][col] = dot;
                }
            }
        }

        // Toggle a specific dot
        function toggleDot(row, col) {
            if (dots[row] && dots[row][col]) {
                dots[row][col].classList.toggle('on');
            }
        }

        // Set a dot to on/off
        function setDot(row, col, state = true, color = 'on') {
            if (dots[row] && dots[row][col]) {
                dots[row][col].classList.remove('on', 'amber', 'red');
                if (state) {
                    dots[row][col].classList.add(color);
                }
            }
        }

        // Clear the entire display
        function clearDisplay() {
            clearInterval(scrollInterval);
            clearInterval(viaScrollInterval);
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    setDot(row, col, false);
                }
            }
        }

        // Show section boundaries
        function showSections() {
            clearDisplay();
            
            // Route section border (left 25 columns)
            for (let row = 0; row < ROWS; row++) {
                setDot(row, 24, true, 'amber'); // Right border of route section
            }
            
            // Horizontal divider between destination and via (at row 10)
            for (let col = 40; col < COLS; col++) {
                setDot(10, col, true, 'red'); // Divider line
            }
            
            // Display section labels
            displayText("ROUTE", 0, 10, 'on');
            displayText("DESTINATION", 42, 2, 'on');
            displayText("VIA", 42, 12, 'on');
        }

        // Display bus information in the 3 sections
        function displayBusInfo() {
            clearDisplay();
            
            const route = document.getElementById('routeInput').value || '';
            const destination = document.getElementById('destinationInput').value || '';
            const via = document.getElementById('viaInput').value || '';
            
            // Display route number horizontally in left section
            displayRouteHorizontal(route);
            
            // Display destination in top-right section (2px bigger than via)
            displayDestinationText(destination, 42, 0, 'on');
            
            // Display via in bottom-right section (with scrolling if needed)
            displayViaText(via);
            
            // Add section dividers (commented out)
            /*
            for (let row = 0; row < ROWS; row++) {
                setDot(row, 42, true, 'red'); // Vertical divider
            }
            for (let col = 21; col < COLS; col++) {
                setDot(10, col, true, 'red'); // Horizontal divider
            }
            */
        }

        // Display route number horizontally in left section, scaled to fit
        function displayRouteHorizontal(route) {
            const sectionWidth = 40; // Left section is 40 columns wide (0-39)
            const sectionHeight = ROWS; // Full height
            const routeLength = route.length;
            
            if (routeLength === 0) return;
            
            // Calculate a reasonable character size that fits well without extreme stretching
            const spacing = 2;
            const maxCharWidth = 15; // Maximum character width to avoid over-stretching
            const maxCharHeight = 25; // Maximum character height
            
            // Calculate width needed with max size
            const maxWidthNeeded = (maxCharWidth + spacing) * routeLength - spacing;
            
            let charWidth, charHeight;
            
            if (maxWidthNeeded <= sectionWidth) {
                // Use max size if it fits
                charWidth = maxCharWidth;
                charHeight = maxCharHeight;
            } else {
                // Scale down to fit width
                charWidth = Math.floor((sectionWidth - spacing * (routeLength - 1)) / routeLength);
                charHeight = Math.min(maxCharHeight, Math.floor(charWidth * 1.4)); // Maintain aspect ratio
            }
            
            // Center the text horizontally
            const textWidth = (charWidth + spacing) * routeLength - spacing;
            const centerOffsetX = Math.floor((sectionWidth - textWidth) / 2);
            
            // Center the text vertically
            const centerOffsetY = Math.floor((sectionHeight - charHeight) / 2);
            
            let currentCol = centerOffsetX;
            
            for (let i = 0; i < route.length; i++) {
                const char = route[i];
                // Always use scaled character rendering to fill the available space
                displayScaledChar(char, currentCol, centerOffsetY, charWidth, charHeight, 'on');
                currentCol += charWidth + spacing;
            }
        }

        // Display a single character at position for route section (no clipping restrictions)
        function displayRouteCharAt(char, startCol, startRow, color) {
            const patterns = getCharacterPatterns();
            const pattern = patterns[char] || patterns[char.toUpperCase()] || patterns[' '];
            
            for (let row = 0; row < pattern.length && startRow + row < ROWS; row++) {
                for (let col = 0; col < pattern[row].length && startCol + col < COLS; col++) {
                    if (pattern[row][col]) {
                        setDot(startRow + row, startCol + col, true, color);
                    }
                }
            }
        }

        // Display destination text with characters 2px bigger than via text
        function displayDestinationText(text, startCol, startRow, color) {
            const charWidth = 9; // 2px bigger than via (5px)
            const charHeight = 16; // 16 pixels tall as requested
            const spacing = 1;
            
            // Calculate text width and center it in the destination section
            const textWidth = (charWidth + spacing) * text.length - spacing;
            const sectionWidth = COLS - startCol; // Available width in destination section
            const centerOffset = Math.floor((sectionWidth - textWidth) / 2);
            let currentCol = startCol + Math.max(0, centerOffset);
            
            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                if (currentCol + charWidth > COLS) break;
                
                // Use scaled character rendering for bigger text
                displayScaledDestinationChar(char, currentCol, startRow, charWidth, charHeight, color);
                currentCol += charWidth + spacing;
            }
        }

        // Display a scaled character for destination text
        function displayScaledDestinationChar(char, startCol, startRow, targetWidth, targetHeight, color) {
            const patterns = getCharacterPatterns();
            const pattern = patterns[char] || patterns[char.toUpperCase()] || patterns[' '];
            
            // Scale the 5x7 pattern to the target size
            const scaleX = targetWidth / 5;
            const scaleY = targetHeight / 7;
            
            for (let row = 0; row < 7; row++) {
                for (let col = 0; col < 5; col++) {
                    if (pattern[row][col]) {
                        // Scale each pixel to fill the target dimensions
                        const scaledStartRow = Math.floor(row * scaleY);
                        const scaledEndRow = Math.min(targetHeight, Math.ceil((row + 1) * scaleY));
                        const scaledStartCol = Math.floor(col * scaleX);
                        const scaledEndCol = Math.min(targetWidth, Math.ceil((col + 1) * scaleX));
                        
                        // Fill the scaled area - for destination section (top 12 rows in 25-row display)
                        for (let r = scaledStartRow; r < scaledEndRow && startRow + r < 16; r++) {
                            for (let c = scaledStartCol; c < scaledEndCol && startCol + c < COLS; c++) {
                                if (startCol + c >= 42) { // Only within destination section
                                    setDot(startRow + r, startCol + c, true, color);
                                }
                            }
                        }
                    }
                }
            }
        }

        // Display via text with scrolling if too long
        function displayViaText(via) {
            const viaSection = {
                startCol: 42,
                startRow: 18, // Start at row 18 for via section in 25-row display
                width: COLS - 42, // Available width in via section
                height: 12 // Available height for text (rows 13-24)
            };
            
            // Calculate if text fits in one line
            const charWidth = 5;
            const spacing = 1;
            const textWidth = (charWidth + spacing) * via.length - spacing;
            
            if (textWidth <= viaSection.width) {
                // Text fits - display centered
                const centerOffset = Math.floor((viaSection.width - textWidth) / 2);
                const centeredStartCol = viaSection.startCol + Math.max(0, centerOffset);
                displayText(via, centeredStartCol, viaSection.startRow, 'amber');
            } else {
                // Text is too long - display static first, then scroll after 2 seconds
                // First display the text statically
                displayText(via, viaSection.startCol, viaSection.startRow, 'amber');
                
                // Wait 2 seconds before starting to scroll
                setTimeout(() => {
                    let offset = 0;
                    
                    viaScrollInterval = setInterval(() => {
                        // Clear only the via section
                        for (let row = viaSection.startRow; row < viaSection.startRow + viaSection.height; row++) {
                            for (let col = viaSection.startCol; col < COLS; col++) {
                                if (row !== 10) { // Don't clear the divider line
                                    setDot(row, col, false);
                                }
                            }
                        }
                        
                        // Display scrolling text pixel by pixel
                        displayScrollingText(via, viaSection.startCol - offset, viaSection.startRow, viaSection.width, 'amber');
                        
                        offset++;
                        // Reset when text is completely off screen
                        if (offset > textWidth + viaSection.width) {
                            offset = 0;
                        }
                    }, 80); // Faster scroll speed for pixel-by-pixel movement
                }, 2000); // 2 second delay before scrolling starts
            }
        }

        // Display scrolling text within bounds
        function displayScrollingText(text, startCol, startRow, maxWidth, color) {
            const charWidth = 5;
            const spacing = 1;
            let currentCol = startCol;
            
            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                
                // Display character if any part of it is visible in the section
                if (currentCol + charWidth > 42 && currentCol < COLS) {
                    displayCharAt(char, currentCol, startRow, color);
                }
                
                currentCol += charWidth + spacing;
                
                // Stop if we've gone too far past the visible area
                if (currentCol > COLS + 20) break;
            }
        }
        
        // Display a scaled character with horizontal squishing from both sides
        function displayScaledChar(char, startCol, startRow, targetWidth, targetHeight, color) {
            const patterns = getCharacterPatterns();
            const pattern = patterns[char] || patterns[char.toUpperCase()] || patterns[' '];
            
            // Scale the 5x7 pattern to the target size
            const scaleX = targetWidth / 5;
            const scaleY = targetHeight / 7;
            
            for (let row = 0; row < 7; row++) {
                for (let col = 0; col < 5; col++) {
                    if (pattern[row][col]) {
                        // Scale each pixel to fill the target dimensions
                        const scaledStartRow = Math.floor(row * scaleY);
                        const scaledEndRow = Math.min(targetHeight, Math.ceil((row + 1) * scaleY));
                        const scaledStartCol = Math.floor(col * scaleX);
                        const scaledEndCol = Math.min(targetWidth, Math.ceil((col + 1) * scaleX));
                        
                        // Fill the scaled area
                        for (let r = scaledStartRow; r < scaledEndRow && startRow + r < ROWS; r++) {
                            for (let c = scaledStartCol; c < scaledEndCol && startCol + c < 40; c++) {
                                setDot(startRow + r, startCol + c, true, color);
                            }
                        }
                    }
                }
            }
        }

        // Display text horizontally
        function displayText(text, startCol, startRow, color) {
            const charWidth = 5;
            const spacing = 1;
            let currentCol = startCol;
            
            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                if (currentCol + charWidth > COLS) break;
                
                displayCharAt(char, currentCol, startRow, color);
                currentCol += charWidth + spacing;
            }
        }

        // Display a single character at position with proper clipping
        function displayCharAt(char, startCol, startRow, color) {
            const patterns = getCharacterPatterns();
            const pattern = patterns[char] || patterns[char.toUpperCase()] || patterns[' '];
            
            for (let row = 0; row < pattern.length && startRow + row < ROWS; row++) {
                for (let col = 0; col < pattern[row].length && startCol + col < COLS; col++) {
                    if (pattern[row][col]) {
                        // Only draw pixels that are within the via section boundaries (col >= 42)
                        if (startCol + col >= 42) {
                            setDot(startRow + row, startCol + col, true, color);
                        }
                    }
                }
            }
        }

        // Get character patterns (5x7 pixel font)
        function getCharacterPatterns() {
            return {
                'A': [
                    [0,1,1,1,0],
                    [1,0,0,0,1],
                    [1,0,0,0,1],
                    [1,1,1,1,1],
                    [1,0,0,0,1],
                    [1,0,0,0,1],
                    [1,0,0,0,1]
                ],
                'B': [
                    [1,1,1,1,0],
                    [1,0,0,0,1],
                    [1,0,0,0,1],
                    [1,1,1,1,0],
                    [1,0,0,0,1],
                    [1,0,0,0,1],
                    [1,1,1,1,0]
                ],
                'C': [
                    [0,1,1,1,0],
                    [1,0,0,0,1],
                    [1,0,0,0,0],
                    [1,0,0,0,0],
                    [1,0,0,0,0],
                    [1,0,0,0,1],
                    [0,1,1,1,0]
                ],
                'D': [
                    [1,1,1,1,0],
                    [1,0,0,0,1],
                    [1,0,0,0,1],
                    [1,0,0,0,1],
                    [1,0,0,0,1],
                    [1,0,0,0,1],
                    [1,1,1,1,0]
                ],
                'E': [
                    [1,1,1,1,1],
                    [1,0,0,0,0],
                    [1,0,0,0,0],
                    [1,1,1,1,0],
                    [1,0,0,0,0],
                    [1,0,0,0,0],
                    [1,1,1,1,1]
                ],
                'F': [
                    [1,1,1,1,1],
                    [1,0,0,0,0],
                    [1,0,0,0,0],
                    [1,1,1,1,0],
                    [1,0,0,0,0],
                    [1,0,0,0,0],
                    [1,0,0,0,0]
                ],
                'G': [
                    [0,1,1,1,0],
                    [1,0,0,0,1],
                    [1,0,0,0,0],
                    [1,0,1,1,1],
                    [1,0,0,0,1],
                    [1,0,0,0,1],
                    [0,1,1,1,0]
                ],
                'H': [
                    [1,0,0,0,1],
                    [1,0,0,0,1],
                    [1,0,0,0,1],
                    [1,1,1,1,1],
                    [1,0,0,0,1],
                    [1,0,0,0,1],
                    [1,0,0,0,1]
                ],
                'I': [
                    [1,1,1,1,1],
                    [0,0,1,0,0],
                    [0,0,1,0,0],
                    [0,0,1,0,0],
                    [0,0,1,0,0],
                    [0,0,1,0,0],
                    [1,1,1,1,1]
                ],
                'J': [
                    [1,1,1,1,1],
                    [0,0,0,1,0],
                    [0,0,0,1,0],
                    [0,0,0,1,0],
                    [0,0,0,1,0],
                    [1,0,0,1,0],
                    [0,1,1,0,0]
                ],
                'K': [
                    [1,0,0,0,1],
                    [1,0,0,1,0],
                    [1,0,1,0,0],
                    [1,1,0,0,0],
                    [1,0,1,0,0],
                    [1,0,0,1,0],
                    [1,0,0,0,1]
                ],
                'L': [
                    [1,0,0,0,0],
                    [1,0,0,0,0],
                    [1,0,0,0,0],
                    [1,0,0,0,0],
                    [1,0,0,0,0],
                    [1,0,0,0,0],
                    [1,1,1,1,1]
                ],
                'M': [
                    [0,0,0,0,0],
                    [1,0,0,0,1],
                    [1,1,0,1,1],
                    [1,0,1,0,1],
                    [1,0,0,0,1],
                    [1,0,0,0,1],
                    [1,0,0,0,1]
                ],
                'N': [
                    [1,0,0,0,1],
                    [1,0,0,0,1],
                    [1,1,0,0,1],
                    [1,0,1,0,1],
                    [1,0,0,1,1],
                    [1,0,0,0,1],
                    [1,0,0,0,1]
                ],
                'O': [
                    [0,1,1,1,0],
                    [1,0,0,0,1],
                    [1,0,0,0,1],
                    [1,0,0,0,1],
                    [1,0,0,0,1],
                    [1,0,0,0,1],
                    [0,1,1,1,0]
                ],
                'P': [
                    [1,1,1,1,0],
                    [1,0,0,0,1],
                    [1,0,0,0,1],
                    [1,1,1,1,0],
                    [1,0,0,0,0],
                    [1,0,0,0,0],
                    [1,0,0,0,0]
                ],
                'Q': [
                    [0,1,1,1,0],
                    [1,0,0,0,1],
                    [1,0,0,0,1],
                    [1,0,0,0,1],
                    [1,0,1,0,1],
                    [1,0,0,1,0],
                    [0,1,1,0,1]
                ],
                'R': [
                    [1,1,1,1,0],
                    [1,0,0,0,1],
                    [1,0,0,0,1],
                    [1,1,1,1,0],
                    [1,0,1,0,0],
                    [1,0,0,1,0],
                    [1,0,0,0,1]
                ],
                'S': [
                    [0,1,1,1,0],
                    [1,0,0,0,1],
                    [1,0,0,0,0],
                    [0,1,1,1,0],
                    [0,0,0,0,1],
                    [1,0,0,0,1],
                    [0,1,1,1,0]
                ],
                'T': [
                    [1,1,1,1,1],
                    [0,0,1,0,0],
                    [0,0,1,0,0],
                    [0,0,1,0,0],
                    [0,0,1,0,0],
                    [0,0,1,0,0],
                    [0,0,1,0,0]
                ],
                'U': [
                    [1,0,0,0,1],
                    [1,0,0,0,1],
                    [1,0,0,0,1],
                    [1,0,0,0,1],
                    [1,0,0,0,1],
                    [1,0,0,0,1],
                    [0,1,1,1,0]
                ],
                'V': [
                    [1,0,0,0,1],
                    [1,0,0,0,1],
                    [1,0,0,0,1],
                    [1,0,0,0,1],
                    [1,0,0,0,1],
                    [0,1,0,1,0],
                    [0,0,1,0,0]
                ],
                'W': [
                    [1,0,0,0,1],
                    [1,0,0,0,1],
                    [1,0,0,0,1],
                    [1,0,0,0,1],
                    [1,0,1,0,1],
                    [1,1,0,1,1],
                    [1,0,0,0,1]
                ],
                'X': [
                    [1,0,0,0,1],
                    [1,0,0,0,1],
                    [0,1,0,1,0],
                    [0,0,1,0,0],
                    [0,1,0,1,0],
                    [1,0,0,0,1],
                    [1,0,0,0,1]
                ],
                'Y': [
                    [1,0,0,0,1],
                    [0,1,0,1,0],
                    [0,0,1,0,0],
                    [0,0,1,0,0],
                    [0,0,1,0,0],
                    [0,0,1,0,0],
                    [0,0,1,0,0]
                ],
                'Z': [
                    [1,1,1,1,1],
                    [0,0,0,0,1],
                    [0,0,0,1,0],
                    [0,0,1,0,0],
                    [0,1,0,0,0],
                    [1,0,0,0,0],
                    [1,1,1,1,1]
                ],
                '0': [
                    [0,1,1,1,0],
                    [1,0,0,0,1],
                    [1,0,0,1,1],
                    [1,0,1,0,1],
                    [1,1,0,0,1],
                    [1,0,0,0,1],
                    [0,1,1,1,0]
                ],
                '1': [
                    [0,0,1,0,0],
                    [0,1,1,0,0],
                    [0,0,1,0,0],
                    [0,0,1,0,0],
                    [0,0,1,0,0],
                    [0,0,1,0,0],
                    [0,1,1,1,0]
                ],
                '2': [
                    [0,1,1,1,0],
                    [1,0,0,0,1],
                    [0,0,0,0,1],
                    [0,0,0,1,0],
                    [0,0,1,0,0],
                    [0,1,0,0,0],
                    [1,1,1,1,1]
                ],
                '3': [
                    [0,1,1,1,0],
                    [1,0,0,0,1],
                    [0,0,0,0,1],
                    [0,0,1,1,0],
                    [0,0,0,0,1],
                    [1,0,0,0,1],
                    [0,1,1,1,0]
                ],
                '4': [
                    [0,0,0,1,0],
                    [0,0,1,1,0],
                    [0,1,0,1,0],
                    [1,0,0,1,0],
                    [1,1,1,1,1],
                    [0,0,0,1,0],
                    [0,0,0,1,0]
                ],
                '5': [
                    [1,1,1,1,1],
                    [1,0,0,0,0],
                    [1,1,1,1,0],
                    [0,0,0,0,1],
                    [0,0,0,0,1],
                    [1,0,0,0,1],
                    [0,1,1,1,0]
                ],
                '6': [
                    [0,1,1,1,0],
                    [1,0,0,0,1],
                    [1,0,0,0,0],
                    [1,1,1,1,0],
                    [1,0,0,0,1],
                    [1,0,0,0,1],
                    [0,1,1,1,0]
                ],
                '7': [
                    [1,1,1,1,1],
                    [0,0,0,0,1],
                    [0,0,0,1,0],
                    [0,0,1,0,0],
                    [0,1,0,0,0],
                    [0,1,0,0,0],
                    [0,1,0,0,0]
                ],
                '8': [
                    [0,1,1,1,0],
                    [1,0,0,0,1],
                    [1,0,0,0,1],
                    [0,1,1,1,0],
                    [1,0,0,0,1],
                    [1,0,0,0,1],
                    [0,1,1,1,0]
                ],
                '9': [
                    [0,1,1,1,0],
                    [1,0,0,0,1],
                    [1,0,0,0,1],
                    [0,1,1,1,1],
                    [0,0,0,0,1],
                    [1,0,0,0,1],
                    [0,1,1,1,0]
                ],
                ' ': [
                    [0,0,0,0,0],
                    [0,0,0,0,0],
                    [0,0,0,0,0],
                    [0,0,0,0,0],
                    [0,0,0,0,0],
                    [0,0,0,0,0],
                    [0,0,0,0,0]
                ],
                '-': [
                    [0,0,0,0,0],
                    [0,0,0,0,0],
                    [0,0,0,0,0],
                    [1,1,1,1,1],
                    [0,0,0,0,0],
                    [0,0,0,0,0],
                    [0,0,0,0,0]
                ],
                ':': [
                    [1,1,0,0,0],
                    [1,1,0,0,0],
                    [0,0,0,0,0],
                    [0,0,0,0,0],
                    [0,0,0,0,0],
                    [1,1,0,0,0],
                    [1,1,0,0,0]
                ],
                ',': [
                    [0,0,0,0,0],
                    [0,0,0,0,0],
                    [0,0,0,0,0],
                    [0,0,0,0,0],
                    [0,1,1,0,0],
                    [0,1,1,0,0],
                    [1,1,0,0,0]
                ],
                '>': [
                    [1,0,0,0,0],
                    [0,1,0,0,0],
                    [0,0,1,0,0],
                    [0,0,0,1,0],
                    [0,0,1,0,0],
                    [0,1,0,0,0],
                    [1,0,0,0,0]
                ],
                // Lowercase letters
                'a': [
                    [0,0,0,0,0],
                    [0,0,0,0,0],
                    [0,1,1,1,0],
                    [0,0,0,0,1],
                    [0,1,1,1,1],
                    [1,0,0,0,1],
                    [0,1,1,1,1]
                ],
                'b': [
                    [1,0,0,0,0],
                    [1,0,0,0,0],
                    [1,1,1,1,0],
                    [1,0,0,0,1],
                    [1,0,0,0,1],
                    [1,0,0,0,1],
                    [1,1,1,1,0]
                ],
                'c': [
                    [0,0,0,0,0],
                    [0,0,0,0,0],
                    [0,1,1,1,1],
                    [1,0,0,0,0],
                    [1,0,0,0,0],
                    [1,0,0,0,0],
                    [0,1,1,1,1]
                ],
                'd': [
                    [0,0,0,0,1],
                    [0,0,0,0,1],
                    [0,1,1,1,1],
                    [1,0,0,0,1],
                    [1,0,0,0,1],
                    [1,0,0,0,1],
                    [0,1,1,1,1]
                ],
                'e': [
                    [0,0,0,0,0],
                    [0,0,0,0,0],
                    [0,1,1,1,0],
                    [1,0,0,0,1],
                    [1,1,1,1,1],
                    [1,0,0,0,0],
                    [0,1,1,1,1]
                ],
                'f': [
                    [0,0,1,1,1],
                    [0,1,0,0,0],
                    [1,1,1,1,0],
                    [0,1,0,0,0],
                    [0,1,0,0,0],
                    [0,1,0,0,0],
                    [0,1,0,0,0]
                ],
                'g': [
                    [0,0,0,0,0],
                    [0,1,1,1,1],
                    [1,0,0,0,1],
                    [1,0,0,0,1],
                    [0,1,1,1,1],
                    [0,0,0,0,1],
                    [0,1,1,1,0]
                ],
                'h': [
                    [1,0,0,0,0],
                    [1,0,0,0,0],
                    [1,1,1,1,0],
                    [1,0,0,0,1],
                    [1,0,0,0,1],
                    [1,0,0,0,1],
                    [1,0,0,0,1]
                ],
                'i': [
                    [0,0,1,0,0],
                    [0,0,0,0,0],
                    [0,1,1,0,0],
                    [0,0,1,0,0],
                    [0,0,1,0,0],
                    [0,0,1,0,0],
                    [0,1,1,1,0]
                ],
                'j': [
                    [0,0,0,1,0],
                    [0,0,0,0,0],
                    [0,0,1,1,0],
                    [0,0,0,1,0],
                    [0,0,0,1,0],
                    [1,0,0,1,0],
                    [0,1,1,0,0]
                ],
                'k': [
                    [1,0,0,0,0],
                    [1,0,0,0,0],
                    [1,0,0,1,0],
                    [1,0,1,0,0],
                    [1,1,0,0,0],
                    [1,0,1,0,0],
                    [1,0,0,1,0]
                ],
                'l': [
                    [0,1,1,0,0],
                    [0,0,1,0,0],
                    [0,0,1,0,0],
                    [0,0,1,0,0],
                    [0,0,1,0,0],
                    [0,0,1,0,0],
                    [0,1,1,1,0]
                ],
                'm': [
                    [0,0,0,0,0],
                    [0,0,0,0,0],
                    [1,1,0,1,0],
                    [1,0,1,0,1],
                    [1,0,1,0,1],
                    [1,0,1,0,1],
                    [1,0,1,0,1]
                ],
                'n': [
                    [0,0,0,0,0],
                    [0,0,0,0,0],
                    [1,1,1,1,0],
                    [1,0,0,0,1],
                    [1,0,0,0,1],
                    [1,0,0,0,1],
                    [1,0,0,0,1]
                ],
                'o': [
                    [0,0,0,0,0],
                    [0,0,0,0,0],
                    [0,1,1,1,0],
                    [1,0,0,0,1],
                    [1,0,0,0,1],
                    [1,0,0,0,1],
                    [0,1,1,1,0]
                ],
                'p': [
                    [0,0,0,0,0],
                    [0,0,0,0,0],
                    [1,1,1,1,0],
                    [1,0,0,0,1],
                    [1,1,1,1,0],
                    [1,0,0,0,0],
                    [1,0,0,0,0]
                ],
                'q': [
                    [0,0,0,0,0],
                    [0,0,0,0,0],
                    [0,1,1,1,1],
                    [1,0,0,0,1],
                    [0,1,1,1,1],
                    [0,0,0,0,1],
                    [0,0,0,0,1]
                ],
                'r': [
                    [0,0,0,0,0],
                    [0,0,0,0,0],
                    [1,0,1,1,1],
                    [1,1,0,0,0],
                    [1,0,0,0,0],
                    [1,0,0,0,0],
                    [1,0,0,0,0]
                ],
                's': [
                    [0,0,0,0,0],
                    [0,0,0,0,0],
                    [0,1,1,1,1],
                    [1,0,0,0,0],
                    [0,1,1,1,0],
                    [0,0,0,0,1],
                    [1,1,1,1,0]
                ],
                't': [
                    [0,1,0,0,0],
                    [0,1,0,0,0],
                    [1,1,1,1,0],
                    [0,1,0,0,0],
                    [0,1,0,0,0],
                    [0,1,0,0,0],
                    [0,0,1,1,1]
                ],
                'u': [
                    [0,0,0,0,0],
                    [0,0,0,0,0],
                    [1,0,0,0,1],
                    [1,0,0,0,1],
                    [1,0,0,0,1],
                    [1,0,0,0,1],
                    [0,1,1,1,1]
                ],
                'v': [
                    [0,0,0,0,0],
                    [0,0,0,0,0],
                    [1,0,0,0,1],
                    [1,0,0,0,1],
                    [1,0,0,0,1],
                    [0,1,0,1,0],
                    [0,0,1,0,0]
                ],
                'w': [
                    [0,0,0,0,0],
                    [0,0,0,0,0],
                    [1,0,0,0,1],
                    [1,0,1,0,1],
                    [1,0,1,0,1],
                    [1,0,1,0,1],
                    [0,1,0,1,0]
                ],
                'x': [
                    [0,0,0,0,0],
                    [0,0,0,0,0],
                    [1,0,0,0,1],
                    [0,1,0,1,0],
                    [0,0,1,0,0],
                    [0,1,0,1,0],
                    [1,0,0,0,1]
                ],
                'y': [
                    [0,0,0,0,0],
                    [0,0,0,0,0],
                    [1,0,0,0,1],
                    [1,0,0,0,1],
                    [0,1,1,1,1],
                    [0,0,0,0,1],
                    [0,1,1,1,0]
                ],
                'z': [
                    [0,0,0,0,0],
                    [0,0,0,0,0],
                    [1,1,1,1,1],
                    [0,0,0,1,0],
                    [0,0,1,0,0],
                    [0,1,0,0,0],
                    [1,1,1,1,1]
                ]
            };
        }

        // Pattern 1: Route number (full height) + Destination only (no via)
        function displayPattern1() {
            clearDisplay();
            
            const route = document.getElementById('routeInput').value || '';
            const destination = document.getElementById('destinationInput').value || '';
            
            // Display route number horizontally in left section (full height)
            displayRouteHorizontal(route);
            
            // Display destination in right section (full height, bigger text)
            displayFullDestinationText(destination, 42, 0, 'on');
        }

        // Pattern 2: Normal (current) - Route + Destination + Via
        function displayPattern2() {
            displayBusInfo(); // Use the existing function
        }

        // Pattern 3: Destination only (full width and height)
        function displayPattern3() {
            clearDisplay();
            
            const destination = document.getElementById('destinationInput').value || '';
            
            // Display destination across full width and height
            displayFullWidthDestination(destination);
        }

        // Display destination text using full right section height
        function displayFullDestinationText(text, startCol, startRow, color) {
            const charWidth = 12; // Bigger character width for full height display
            const charHeight = ROWS; // Use full height of the display
            const spacing = 2;
            
            // Calculate text width and center it in the destination section
            const textWidth = (charWidth + spacing) * text.length - spacing;
            const sectionWidth = COLS - startCol; // Available width in destination section
            const centerOffset = Math.floor((sectionWidth - textWidth) / 2);
            let currentCol = startCol + Math.max(0, centerOffset);
            
            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                if (currentCol + charWidth > COLS) break;
                
                // Use scaled character rendering for bigger text
                displayScaledFullChar(char, currentCol, startRow, charWidth, charHeight, color);
                currentCol += charWidth + spacing;
            }
        }

        // Display destination across full width and height
        function displayFullWidthDestination(text) {
            const availableWidth = COLS; // Full width
            const availableHeight = ROWS; // Full height
            const textLength = text.length;
            
            if (textLength === 0) return;
            
            // Calculate a reasonable character size that fits well without extreme stretching
            const spacing = 2;
            const maxCharWidth = 20; // Maximum character width to avoid over-stretching
            const maxCharHeight = 25; // Maximum character height
            
            // Calculate width needed with max size
            const maxWidthNeeded = (maxCharWidth + spacing) * textLength - spacing;
            
            let charWidth, charHeight;
            
            if (maxWidthNeeded <= availableWidth) {
                // Use max size if it fits
                charWidth = maxCharWidth;
                charHeight = maxCharHeight;
            } else {
                // Scale down to fit width
                charWidth = Math.floor((availableWidth - spacing * (textLength - 1)) / textLength);
                charHeight = Math.min(maxCharHeight, Math.floor(charWidth * 1.4)); // Maintain aspect ratio
            }
            
            // Center the text horizontally
            const textWidth = (charWidth + spacing) * textLength - spacing;
            const centerOffsetX = Math.floor((availableWidth - textWidth) / 2);
            
            // Center the text vertically
            const centerOffsetY = Math.floor((availableHeight - charHeight) / 2);
            
            let currentCol = centerOffsetX;
            
            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                displayScaledFullChar(char, currentCol, centerOffsetY, charWidth, charHeight, 'on');
                currentCol += charWidth + spacing;
            }
        }

        // Display a scaled character for full-size text
        function displayScaledFullChar(char, startCol, startRow, targetWidth, targetHeight, color) {
            const patterns = getCharacterPatterns();
            const pattern = patterns[char] || patterns[char.toUpperCase()] || patterns[' '];
            
            // Scale the 5x7 pattern to the target size
            const scaleX = targetWidth / 5;
            const scaleY = targetHeight / 7;
            
            for (let row = 0; row < 7; row++) {
                for (let col = 0; col < 5; col++) {
                    if (pattern[row][col]) {
                        // Scale each pixel to fill the target dimensions
                        const scaledStartRow = Math.floor(row * scaleY);
                        const scaledEndRow = Math.min(targetHeight, Math.ceil((row + 1) * scaleY));
                        const scaledStartCol = Math.floor(col * scaleX);
                        const scaledEndCol = Math.min(targetWidth, Math.ceil((col + 1) * scaleX));
                        
                        // Fill the scaled area
                        for (let r = scaledStartRow; r < scaledEndRow && startRow + r < ROWS; r++) {
                            for (let c = scaledStartCol; c < scaledEndCol && startCol + c < COLS; c++) {
                                setDot(startRow + r, startCol + c, true, color);
                            }
                        }
                    }
                }
            }
        }

        // Initialize the matrix when page loads
        window.addEventListener('load', initMatrix);
        
        // Initialize Select2 dropdown
        $(document).ready(function() {
            initializeRouteDropdown();
        });
        
        function initializeRouteDropdown() {
            $('#routeSelect').select2({
                placeholder: 'Search for a route...',
                ajax: {
                    url: '/api/operator/route/',
                    dataType: 'json',
                    delay: 250,
                    data: function (params) {
                        return {
                            search: params.term || ''
                        };
                    },
                    processResults: function (data, params) {
                        console.log('API Response:', data); // Debug logging
                        
                        // Handle paginated response - extract results array
                        let routeData = data;
                        if (data && data.results && Array.isArray(data.results)) {
                            routeData = data.results;
                        } else if (!Array.isArray(data)) {
                            console.error('Expected array or paginated response but got:', typeof data, data);
                            return { results: [] };
                        }
                        
                        return {
                            results: routeData.map(function(route) {
                                return {
                                    id: route.id || route.route_num,
                                    text: route.full_searchable_name || `${route.route_num} - ${route.inbound_destination}`,
                                    route: route
                                };
                            })
                        };
                    },
                    transport: function (params, success, failure) {
                        var $request = $.ajax(params);
                        $request.then(success);
                        $request.fail(function(jqXHR, textStatus, errorThrown) {
                            console.error('AJAX Error:', textStatus, errorThrown);
                            console.error('Response:', jqXHR.responseText);
                            failure();
                        });
                        return $request;
                    },
                    cache: true
                },
                minimumInputLength: 0,
                allowClear: true
            });
            
            $('#routeSelect').on('select2:select', function (e) {
                const routeData = e.params.data.route;
                const isInbound = $('#directionToggle').is(':checked');
                
                // Update the input fields
                document.getElementById('routeInput').value = routeData.route_num || '';
                const destination = isInbound ? routeData.inbound_destination : routeData.outbound_destination;
                document.getElementById('destinationInput').value = destination || '';
                
                // Auto-display the selected route
                displayPattern1();
            });
            
            $('#directionToggle').on('change', function() {
                const selectedData = $('#routeSelect').select2('data')[0];
                if (selectedData && selectedData.route) {
                    const routeData = selectedData.route;
                    const isInbound = $('#directionToggle').is(':checked');
                    const destination = isInbound ? routeData.inbound_destination : routeData.outbound_destination;
                    document.getElementById('destinationInput').value = destination || '';
                    
                    // Auto-display the updated route
                    displayPattern1();
                }
            });
        }
    </script>
</body>
</html>