{% extends 'mbtbase.html' %}
{% load static %}

{% block title %}Live Route Map{% endblock %}

{% block extra_css %}
<link rel="stylesheet" href="/static/css/leaflet.css">

<style>
  html,
  body,
  main {
    height: 100%;
    margin: 0;
    padding: 0;
  }

  #map {
    position: fixed !important;
    top: 55px;
    bottom: 0;
    width: 100%;
    left: 0;
  }

  .vehicle-marker {
    border: 1px solid var(--marker-border-color);
    text-align: center;
    color: #000;
    text-anchor: middle;
    paint-order: stroke;
    stroke-width: 2px;
    background: #fff;
    width: 24px;
    height: 16px;
    margin: 1px;
    line-height: 16px;
    display: block;
    overflow: hidden;
  }
</style>
{% endblock %}

{% block extra_js %}
<script src="/static/js/leaflet.js"></script>
{% endblock %}

{% block content %}
<div id="map"></div>
<!-- some other script in your page expects an element with id="timer" -->
<div id="timer" style="display:none"></div>

<script>
  const map = L.map('map').setView([54.238, -3.325], 6);

  L.tileLayer('https://map.mybustimes.cc/tile/{z}/{x}/{y}.png', {
    attribution: '© OpenStreetMap contributors'
  }).addTo(map);

  const markersLayer = L.layerGroup().addTo(map);
  const stopMarkersLayer = L.layerGroup().addTo(map);
  const btMarkersLayer = L.layerGroup().addTo(map); // BusTimes overlay layer

  // --- Helpers ---
  function timeAgo(dateString) {
    if (!dateString) return '';
    const seconds = Math.floor((new Date() - new Date(dateString)) / 1000);
    if (seconds < 60) return `${seconds} second${seconds !== 1 ? 's' : ''} ago`;
    const minutes = Math.floor(seconds / 60);
    if (minutes < 60) return `${minutes} minute${minutes !== 1 ? 's' : ''} ago`;
    const hours = Math.floor(minutes / 60);
    if (hours < 24) return `${hours} hour${hours !== 1 ? 's' : ''} ago`;
    const days = Math.floor(hours / 24);
    return `${days} day${days !== 1 ? 's' : ''} ago`;
  }

  // creates a simple livery-like div icon; supports either a flat colour or a CSS gradient string via `css`
  function createLiveryIcon({ label = '', rotation = 0, bg = '#0000', css = null, textColour = '#fff', textStroke = "#0000", strokeWidth = "0px" } = {}) {
    const normalisedRotation = ((rotation % 360) + 360) % 360;
    const cellRotation = (normalisedRotation < 90 || normalisedRotation > 270) ? 0 : 180;
    const backgroundStyle = css ? `background: ${css};` : `background: ${bg};`;
    const html = `
      <div style="display:inline-block; transform: rotate(${rotation}deg);">
        <svg width="24" height="16" data-vehicle-id="51623" class="vehicle-marker" style="stroke: ${textStroke}; text-align: center; ${backgroundStyle} transform: rotate(${cellRotation}deg); border: 1px solid rgba(0,0,0,0.4); color: ${textColour}; fill: ${textColour}; stroke-width: ${strokeWidth};">
          <text x="12" y="12">${label}</text>
        </svg>
        <span style="display:flex; margin-top: -22px; margin-left: 18px; color:black;">
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24">
            <path d="M8 6.65v10.69c0 .64.76.99 1.24.56l6.11-5.35c.34-.3.34-.83 0-1.13L9.24 6.07C8.76 5.65 8 5.99 8 6.63Z" />
          </svg>
        </span>
      </div>
      
      
    `;
    return L.divIcon({
      className: '',
      html,
      iconSize: [40, 22],
      iconAnchor: [20, 11]
    });
  }

  // --- Active-trips markers (your existing API) ---
  async function refreshMarkers() {
    try {
      const response = await fetch('/api/active_trips');
      if (!response.ok) throw new Error('Failed to fetch active_trips');
      const data = await response.json();
      // your API apparently returns { results: [...] } - fall back gracefully
      const vehicles = data.results || data || [];

      markersLayer.clearLayers();

      vehicles.forEach(vehicle => {
        // support several possible tracking shapes
        const tracking = vehicle.tracking_data || vehicle.tracking || {};
        const lat = tracking.X ?? tracking.lat ?? tracking.latitude;
        const lng = tracking.Y ?? tracking.Y ?? tracking.lon ?? tracking.longitude;

        if (lat == null || lng == null) return;

        const heading = tracking.heading ?? tracking.bearing ?? 0;
        const routeNum = vehicle.tracking_route?.route_num || vehicle.tracking_route?.line || vehicle.route || '???';
        const vehicleData = vehicle.tracking_vehicle || {};
        const liveryCss = vehicleData.livery?.left_css || vehicleData.livery?.css || vehicleData.livery?.colour || null;
        const liveryColour = vehicleData.livery?.left_css || vehicleData.livery?.colour || '#ccc';
        const textColour = vehicleData.livery?.text_colour || '#000';

        const icon = createLiveryIcon({
          label: String(routeNum),
          rotation: heading,
          bg: liveryColour,
          css: liveryCss,
          stroke: '',
          textColour
        });

        const popupText = `
          <a href="/operator/${vehicle.tracking_vehicle?.operator}/route/${vehicle.tracking_route?.id}/">${routeNum} to ${vehicle.tracking_end_location || ''}</a>
          <br><a href="/operator/${vehicle.tracking_vehicle?.operator}/vehicles/${vehicle.tracking_vehicle?.id}/">${vehicleData.fleet_number || ''} - ${vehicleData.reg || ''}</a>
          <br><br><span class="time-ago">${timeAgo(vehicle.tracking_updated_at)}</span>
          <br><span>Heading: ${heading}°</span>
        `;

        L.marker([lat, lng], { icon }).bindPopup(popupText).addTo(markersLayer);
      });

    } catch (err) {
      console.error('Error updating markers:', err);
    }
  }

  // --- Stops (only at close zoom) ---
  async function fetchStops(bounds) {
    const zoom = map.getZoom();
    if (zoom < 15) {
      stopMarkersLayer.clearLayers();
      return;
    }

    const query = new URLSearchParams({
      ymax: bounds.getNorth(),
      ymin: bounds.getSouth(),
      xmax: bounds.getEast(),
      xmin: bounds.getWest()
    }).toString();

    try {
      const response = await fetch(`https://ukbuses.org/stops.json?${query}`);
      if (!response.ok) throw new Error('Failed to fetch stops');
      const data = await response.json();
      const features = Array.isArray(data) ? data : (data.features || []);
      stopMarkersLayer.clearLayers();

      for (const f of features) {
        const coords = f.geometry?.coordinates || f.coordinates;
        if (!coords) continue;
        const lng = coords[0], lat = coords[1];
        const name = f.properties?.name || f.name || `Stop ${lat.toFixed(5)}, ${lng.toFixed(5)}`;

        L.circleMarker([lat, lng], {
          radius: 6,
          color: '#2f80ea',
          fillColor: '#ffffff',
          fillOpacity: 1,
          weight: 4
        }).bindPopup(`<a href="/stop/?name=${encodeURIComponent(name)}">${name}</a>`).addTo(stopMarkersLayer);
      }
    } catch (err) {
      console.error('Failed to load stop markers:', err);
    }
  }

  // --- BusTimes.org vehicles (uses the API response you pasted) ---
  async function fetchBTVehicles(bounds) {
    const params = {
      ymax: bounds.getNorth(),
      ymin: bounds.getSouth(),
      xmax: bounds.getEast(),
      xmin: bounds.getWest()
    };
    const query = new URLSearchParams(params).toString();

    try {
      const response = await fetch(`https://ukbuses.org/vehicles.json?${query}`);
      if (!response.ok) throw new Error('Failed to fetch BT vehicles');
      const data = await response.json();

      // support either an array (your pasted sample) or geojson-like { features: [...] }
      const vehicles = Array.isArray(data) ? data : (data.features || []);
      // rule: hide overlay completely if > 100 vehicles
      if (vehicles.length > 1000) {
        btMarkersLayer.clearLayers();
        console.warn(`BusTimes vehicles in view (${vehicles.length}) > 100 — hiding overlay`);
        const cb = document.getElementById('btToggle');
        if (cb) { cb.checked = false; cb.disabled = true; cb.title = 'Too many BT vehicles in view'; }
        return;
      } else {
        const cb = document.getElementById('btToggle');
        if (cb) { cb.disabled = false; cb.title = ''; }
      }

      btMarkersLayer.clearLayers();

      vehicles.slice(0, 1000).forEach(v => {
        // input shape: { coordinates: [lng, lat], heading: 2, service: { line_name }, vehicle: { name, colour, css ... }, ... }
        const coords = v.coordinates || (v.geometry && v.geometry.coordinates);
        if (!coords || coords.length < 2) return;
        const lng = coords[0], lat = coords[1];
        if (lat == null || lng == null) return;

        let heading = v.heading ?? 0;
        const line = v.service?.line_name || '';
        const serviceLink = v.service?.url || '';
        const vehicleLink = v.vehicle?.url || '';
        const dest = v.destination || '';
        const vehicleName = v.vehicle?.name || '';
        const vehicleColour = v.vehicle?.colour || '#0000';
        const whiteText = v.vehicle?.white_text ?? false;
        let textStroke = v.vehicle?.stroke_colour ?? false;
        const livery = v.vehicle?.livery || null;

        rotation = heading;
        heading = heading + 90;

        const left_css = v.vehicle?.left_css || null;
        const right_css = v.vehicle?.right_css || null;

        let css = left_css;

        if (rotation > 180 && rotation < 360) {
          // swap left/right for backwards-facing vehicles
          css = right_css
        } else {
          css = left_css
        }
        
        let textColour = '#000';

        if (whiteText) textColour = '#fff';

        if (v.vehicle?.text_colour) textColour = v.vehicle.text_colour;

        console.log(v.vehicle?.css)

        let strokeWidth = "0px";

        if (textStroke != false) strokeWidth = "2px";

        if (livery == null) {
          textColour = '#000';
          css = "#fff";
        }

        if (v.vehicle?.css) {
          css = v.vehicle.css;
        }

        const icon = createLiveryIcon({
          label: String(line),
          service_link: serviceLink,
          vehicle_link: vehicleLink,
          rotation: heading,
          bg: vehicleColour,
          css: css,
          strokeWidth: strokeWidth,
          textStroke: textStroke,
          textColour
        });

        const popupText = `
        {% if user.is_staff %}
          <a href="https://ukbuses.org${serviceLink}">${line} to ${dest}</a><br>
          <a href="https://ukbuses.org${vehicleLink}">${vehicleName ? `${vehicleName}<br>` : ''}
          ${v.features ? `${v.features}<br>` : ''}
          <small style="margin-top: 0;">${new Date(v.datetime).toLocaleTimeString()}</small>
        {% else %}
          ${line} to ${dest}<br>
          ${vehicleName ? `${vehicleName}<br>` : ''}
          ${v.features ? `${v.features}<br>` : ''}
          <small style="margin-top: 0;">${new Date(v.datetime).toLocaleTimeString()}</small>
        {% endif %}
        `;

        L.marker([lat, lng], { icon }).bindPopup(popupText).addTo(btMarkersLayer);
      });

    } catch (err) {
      console.error('Error fetching BT vehicles:', err);
    }
  }

  // --- small toggle control for BT overlay ---
  const btControl = L.control({ position: 'topright' });
  btControl.onAdd = function () {
    const div = L.DomUtil.create('div', 'bt-toggle-control');
    L.DomEvent.disableClickPropagation(div);
    div.innerHTML = `
      <label style="background: rgba(255,255,255,0.95); padding:6px 8px; font-size:13px; display:inline-flex; align-items:center; color: black;">
        <input id="btToggle" type="checkbox" checked style="margin-right:6px;"> Real Buses
      </label>
    `;
    return div;
  };
  btControl.addTo(map);

  document.addEventListener('DOMContentLoaded', () => {
    const cb = document.getElementById('btToggle');
    if (cb) {
      cb.addEventListener('change', () => {
        if (cb.checked) map.addLayer(btMarkersLayer);
        else map.removeLayer(btMarkersLayer);
      });
    }
  });

  // --- Initial load and periodic refresh ---
  // load functions once first (they are defined above now)
  refreshMarkers();
  fetchStops(map.getBounds());
  fetchBTVehicles(map.getBounds());

  // refresh both sets regularly
  setInterval(() => {
    refreshMarkers();
    fetchBTVehicles(map.getBounds());
  }, 5000); // every 5s

  // refresh stops + bt when the map moves
  map.on('moveend', () => {
    fetchStops(map.getBounds());
    fetchBTVehicles(map.getBounds());
  });
</script>

{% endblock %}
