{% extends 'mbtbase.html' %}
{% load static %}

{% block title %}{{ full_route_num }}{% endblock %}

{% block content %}

<h2>Make a timetable for {{ route.route_num }} {{ direction }} to
  {% if direction == "inbound" %}
  {{ route.inbound_destination }}
  {% else %}
  {{ route.outbound_destination }}
  {% endif %}
</h2>

<form method="POST" class="fleet-edit-wrapper">
  {% csrf_token %}
  <select name="days[]" id="days" multiple required size="7">
    {% for day in days %}
    <option value="{{ day.id }}">{{ day.name }}</option>
    {% endfor %}
  </select>
  <small>Hold <strong>Ctrl</strong> (or <strong>Cmd</strong> on Mac) to select multiple days</small>

  <h3>Auto Fill Options</h3>

  <div>
    <label>Start Time:</label>
    <input type="time" id="autofill-start">
    <label>End Time:</label>
    <input type="time" id="autofill-end">
    <label>Interval (mins):</label>
    <input type="number" id="autofill-interval" min="1" value="15">
    <button type="button" onclick="autoFillTimes()">Auto Fill First Stop</button>
  </div>

  <div>
    <label>Auto Fill Offsets:</label>
    <input type="number" id="offset-fill" min="1" value="1">
    <button type="button" onclick="autoFillOffsets()">Auto Fill Offsets</button>
  </div>

  <br>

  <table style="width: 100%;">
    <thead>
      <tr>
        <th>Stop Name</th>
        <th>Times / Offset</th>
        <th>Timing Point</th>
      </tr>
    </thead>
    <tbody>
      {% for stop in stops.stops %}
      <tr data-stopname="{{ stop.stop }}" data-order="{{ forloop.counter0 }}">
        <td>
          {{ stop.stop }}
          <input type="hidden" name="stop_names" value="{{ stop.stop }}">
          <input type="hidden" name="stop_id_[{{ forloop.counter0 }}]" value="{{ forloop.counter0 }}">
        </td>
        <td>
          {% if forloop.first %}
          <input type="text" name="departure_times" class="departure-times" placeholder="09:00, 10:00" required>
          {% else %}
          <input type="number" name="offset_minutes" class="offset-minutes" min="0" required placeholder="Mins from last stop">
          {% endif %}
        </td>
        <td>
          <input type="checkbox" name="timing_points" class="timing-point" id="timing_point_{{ forloop.counter }}"
            {{ stop.timing_point|yesno:"checked," }}>
        </td>
      </tr>
      {% endfor %}
    </tbody>
  </table>
  <input type="hidden" name="stop_times_json" id="stop-times-json">

  <button type="submit">Save</button>
</form>

<script>
function generateStopTimesJSON() {
  const rows = document.querySelectorAll('tbody tr');
  const output = {}; // dict keyed by index
  let previousTimes = [];

  rows.forEach((row, index) => {
    const stopName = row.dataset.stopname;
    const isTimingPoint = row.querySelector('.timing-point')?.checked ?? false;

    const order = index; // keep row index as order/id

    let times = [];
    if (index === 0) {
      const timesInput = row.querySelector('.departure-times');
      times = timesInput.value.split(',').map(t => t.trim()).filter(Boolean);
      previousTimes = times;
    } else {
      const offsetInput = row.querySelector('.offset-minutes');
      if (!offsetInput) return;

      const offset = parseInt(offsetInput.value || '0', 10);
      times = previousTimes.map(timeStr => {
        let [h, m] = timeStr.split(":").map(Number);
        let totalMins = h * 60 + m + offset;
        let newH = Math.floor(totalMins / 60) % 24;
        let newM = totalMins % 60;
        return `${String(newH).padStart(2, '0')}:${String(newM).padStart(2, '0')}`;
      });
      previousTimes = times;
    }

    // Use index as key
    output[stopName + '_idx_' + index] = {
      stopname: stopName,
      timing_point: isTimingPoint || index === 0, // first stop always timing point
      times: times,
      order: order
    };
  });

  document.getElementById('stop-times-json').value = JSON.stringify(output, null, 2);
}

function autoFillTimes() {
  const start = document.getElementById("autofill-start").value;
  const end = document.getElementById("autofill-end").value;
  const interval = parseInt(document.getElementById("autofill-interval").value, 10);
  const input = document.querySelector('input[name="departure_times"]');

  if (!start || !end || !interval || interval <= 0) {
    alert("Please enter valid start, end times and interval.");
    return;
  }

  const times = [];
  let [startHour, startMin] = start.split(":").map(Number);
  const [endHour, endMin] = end.split(":").map(Number);

  while (
    startHour < endHour || 
    (startHour === endHour && startMin <= endMin)
  ) {
    times.push(
      `${String(startHour).padStart(2, "0")}:${String(startMin).padStart(2, "0")}`
    );
    startMin += interval;
    if (startMin >= 60) {
      startHour += Math.floor(startMin / 60);
      startMin = startMin % 60;
    }
  }

  input.value = times.join(", ");
  generateStopTimesJSON(); // trigger update
}

function autoFillOffsets() {
  const offset = parseInt(document.getElementById("offset-fill").value, 10);
  if (!offset || offset <= 0) {
    alert("Please enter a valid offset value.");
    return;
  }

  const inputs = document.querySelectorAll('input[name="offset_minutes"]');
  inputs.forEach((el, i) => {
    el.value = offset;
  });

  generateStopTimesJSON(); // trigger update
}

document.addEventListener("DOMContentLoaded", function () {
  // Bind all input elements to update the JSON
  document.querySelectorAll('.departure-times, .offset-minutes, .timing-point').forEach(el => {
    el.addEventListener('input', generateStopTimesJSON);
    el.addEventListener('change', generateStopTimesJSON);
  });

  // Trigger once initially in case something is prefilled
  generateStopTimesJSON();
});
</script>

{% endblock %}

{% block extra_css %}
<link rel="stylesheet" href="{% static 'css/narrow.css' %}">
<link rel="stylesheet" href="{% static 'css/select2.css' %}">
{% endblock %}