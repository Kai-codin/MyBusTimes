<!DOCTYPE html>
<html>

<head>
  <title>Select Stops on the Map</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <style>
    #map {
      height: 600px;
      width: 100%;
    }

    .stop-list {
      margin-top: 20px;
    }

    .remove-link {
      margin-left: 10px;
      color: rgb(196, 30, 30);
      cursor: pointer;
    }
  </style>
</head>

<body>
  <h1>Select Stops on the Map</h1>
  <div id="map"></div>
  <div class="stop-list">
    <h3>Selected Stops:</h3>
    <ul id="stopList"></ul>
  </div>

  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script>
    const map = L.map('map').setView([54.238, -3.325], 6);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: 'Â© OpenStreetMap contributors'
    }).addTo(map);

    const stopList = document.getElementById('stopList');
    const selectedStops = [];
    const selectedCoords = [];
    const markersLayer = L.layerGroup().addTo(map);
    let routeLayer = null;

    async function fetchStops(bounds) {
      const zoom = map.getZoom();
      if (zoom < 15) {
        markersLayer.clearLayers();
        return;
      }

      const query = new URLSearchParams({
        ymax: bounds.getNorth(),
        ymin: bounds.getSouth(),
        xmax: bounds.getEast(),
        xmin: bounds.getWest()
      }).toString();

      const response = await fetch(`/bustimesApi/stops?${query}`);
      const data = await response.json();

      markersLayer.clearLayers();

      for (const feature of data.features) {
        const [lng, lat] = feature.geometry.coordinates;
        let name = feature.properties.name || `Unnamed Stop (${lat.toFixed(5)}, ${lng.toFixed(5)})`;
        const coords = [lat, lng];

        // Try to get a better name from bustimes if unnamed
        if (feature.properties.name == null) {
          try {
            const fallbackRes = await fetch(`/bustimesApi/name?lat=${lat}&lon=${lng}`);
            const fallbackData = await fallbackRes.json();
            if (fallbackData.name) {
              name = fallbackData.name;
            }
          } catch (e) {
            console.warn("Could not fetch fallback stop name", e);
          }
        }

        const marker = L.marker(coords).addTo(markersLayer);
        marker.bindPopup(name);

        if (feature.properties.bearing != null) {
          const arrowLength = 0.0003; // ~30 meters, adjust as needed
          const angleRad = feature.properties.bearing * Math.PI / 180;

          const arrowLat = lat + arrowLength * Math.cos(angleRad);
          const arrowLng = lng + arrowLength * Math.sin(angleRad);

          const arrow = L.polyline([[lat, lng], [arrowLat, arrowLng]], {
            color: 'red',
            weight: 2,
            dashArray: '4,4'
          }).addTo(markersLayer);
        }

        marker.on('click', () => {
          if (!selectedStops.includes(name)) {
            selectedStops.push(name);
            selectedCoords.push({
              lat: lat,
              lon: lng,
              heading: feature.properties.bearing || null
            });

            const li = document.createElement('li');
            li.innerHTML = `${name} <span class="remove-link">[Remove]</span>`;
            const removeLink = li.querySelector('.remove-link');

            removeLink.addEventListener('click', () => {
              const index = selectedStops.indexOf(name);
              if (index !== -1) {
                selectedStops.splice(index, 1);
                selectedCoords.splice(index, 1);
                li.remove();
                updateRoute();
              }
            });

            stopList.appendChild(li);
            updateRoute();
          }
        });
      }
    }


    async function updateRoute() {
      if (selectedCoords.length < 2) return;

      const locations = selectedCoords.map((stop, index, array) => {
        const isFirstOrLast = (index === 0 || index === array.length - 1);

        return {
          lat: stop.lat,
          lon: stop.lon,
          type: (index === 0 || index === array.length - 1) ? "break" : "through",
          radius: 1,
          heading: stop.heading ?? undefined,         // Only include if you have it
          heading_tolerance: stop.heading ? 15 : undefined,
          minimum_reachability: 50,
          street_side_tolerance: 5,
          location_type: isFirstOrLast ? 1 : 0
        };
      });

      const response = await fetch('https://valhalla.mybustimes.cc/route', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          locations,
          costing: "bus",
          directions_options: {
            units: "miles",
            avoid_uturns: true,
            maneuver_penalty: 0,
            alley_penalty: 0,
            use_highways: 0.0
          }
        })
      });

      const data = await response.json();

      if (routeLayer) {
        map.removeLayer(routeLayer);
      }

      let fullRoute = [];

      for (const leg of data.trip.legs) {
        const shape = decodeValhallaPolyline(leg.shape);
        fullRoute = fullRoute.concat(shape);
      }

      routeLayer = L.polyline(fullRoute, { color: 'blue', weight: 4 }).addTo(map);
    }

    // Decode Valhalla polyline (6-digit precision)
    function decodeValhallaPolyline(encoded) {
      let index = 0, lat = 0, lng = 0, coordinates = [];

      while (index < encoded.length) {
        let result = 1, shift = 0, b;
        do {
          b = encoded.charCodeAt(index++) - 63 - 1;
          result += b << shift;
          shift += 5;
        } while (b >= 0x1f);
        lat += (result & 1) ? ~(result >> 1) : (result >> 1);

        result = 1;
        shift = 0;
        do {
          b = encoded.charCodeAt(index++) - 63 - 1;
          result += b << shift;
          shift += 5;
        } while (b >= 0x1f);
        lng += (result & 1) ? ~(result >> 1) : (result >> 1);

        coordinates.push([lat * 1e-6, lng * 1e-6]);
      }
      return coordinates;
    }

    fetchStops(map.getBounds());
    map.on('moveend', () => {
      fetchStops(map.getBounds());
    });
  </script>
</body>

</html>